(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{123:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return r})),a.d(t,"rightToc",(function(){return b})),a.d(t,"default",(function(){return c}));var n=a(1),l=(a(0),a(140));const i={title:"MuuriComponent API"},r={id:"api-reference/muuricomponent",title:"MuuriComponent API",description:"# Props",source:"@site/docs\\api-reference\\muuricomponent.mdx",permalink:"/ghtest/docs/api-reference/muuricomponent",editUrl:"https://github.com/paol-imi/muuri-react/edit/master/website/docs/api-reference/muuricomponent.mdx",sidebar:"someSidebar",previous:{title:"useVisibility",permalink:"/ghtest/docs/hooks/useVisibility"},next:{title:"Hooks API",permalink:"/ghtest/docs/api-reference/hooks"}},b=[{value:"Interaction props \u2699\ufe0f",id:"interaction-props-\ufe0f",children:[{value:"ref",id:"ref",children:[]},{value:"id",id:"id",children:[]},{value:"groupIds",id:"groupids",children:[]},{value:"gridProps",id:"gridprops",children:[]},{value:"dragEnabled",id:"dragenabled",children:[]},{value:"filter",id:"filter",children:[]},{value:"sort",id:"sort",children:[]},{value:"sortOptions",id:"sortoptions",children:[]},{value:"addOptions",id:"addoptions",children:[]},{value:"propsToData",id:"propstodata",children:[]},{value:"forceSync",id:"forcesync",children:[]},{value:"instantLayout",id:"instantlayout",children:[]}]},{value:"Layout props \u2699\ufe0f",id:"layout-props-\ufe0f",children:[{value:"Default values",id:"default-values",children:[]},{value:"showDuration",id:"showduration",children:[]},{value:"showEasing",id:"showeasing",children:[]},{value:"hideDuration",id:"hideduration",children:[]},{value:"hideEasing",id:"hideeasing",children:[]},{value:"visibleStyles",id:"visiblestyles",children:[]},{value:"hiddenStyles",id:"hiddenstyles",children:[]},{value:"layout",id:"layout",children:[]},{value:"layoutOnResize",id:"layoutonresize",children:[]},{value:"layoutDuration",id:"layoutduration",children:[]},{value:"layoutEasing",id:"layouteasing",children:[]},{value:"dragFixed",id:"dragfixed",children:[]},{value:"dragContainer",id:"dragcontainer",children:[]},{value:"dragHandle",id:"draghandle",children:[]},{value:"dragStartPredicate",id:"dragstartpredicate",children:[]},{value:"dragAxis",id:"dragaxis",children:[]},{value:"dragSort",id:"dragsort",children:[]},{value:"dragSortHeuristics",id:"dragsortheuristics",children:[]},{value:"dragSortPredicate",id:"dragsortpredicate",children:[]},{value:"dragRelease",id:"dragrelease",children:[]},{value:"dragCssProps",id:"dragcssprops",children:[]},{value:"dragPlaceholder",id:"dragplaceholder",children:[]},{value:"dragAutoScroll",id:"dragautoscroll",children:[]},{value:"containerClass",id:"containerclass",children:[]},{value:"itemClass",id:"itemclass",children:[]},{value:"itemVisibleClass",id:"itemvisibleclass",children:[]},{value:"itemHiddenClass",id:"itemhiddenclass",children:[]},{value:"itemPositioningClass",id:"itempositioningclass",children:[]},{value:"itemDraggingClass",id:"itemdraggingclass",children:[]},{value:"itemReleasingClass",id:"itemreleasingclass",children:[]},{value:"itemPlaceholderClass",id:"itemplaceholderclass",children:[]}]},{value:"Event props \u2699\ufe0f",id:"event-props-\ufe0f",children:[{value:"onSend",id:"onsend",children:[]},{value:"onDragStart",id:"ondragstart",children:[]},{value:"onDragEnd",id:"ondragend",children:[]},{value:"onFilter",id:"onfilter",children:[]},{value:"onSort",id:"onsort",children:[]},{value:"onMount",id:"onmount",children:[]},{value:"onUnmount",id:"onunmount",children:[]}]}],o={rightToc:b};function c({components:e,...t}){return Object(l.b)("wrapper",Object(n.a)({},o,t,{components:e,mdxType:"MDXLayout"}),Object(l.b)("h1",{id:"props"},"Props"),Object(l.b)("p",null,"In this ",Object(l.b)("inlineCode",{parentName:"p"},"documentation")," the props of the MuuriComponent are grouped into three categories in order to clarify their usefulness."),Object(l.b)("h2",{id:"interaction-props-\ufe0f"},"Interaction props \u2699\ufe0f"),Object(l.b)("p",null,"These are the props to use to ",Object(l.b)("inlineCode",{parentName:"p"},"interact")," with the functionality of the MuuriComponent."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#ref"}),"ref")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#id"}),"id")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#groupIds"}),"groupIds")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#gridProps"}),"gridProps")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragenabled"}),"dragEnabled")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#filter"}),"filter")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#sort"}),"sort")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#sortOptions"}),"sortOptions")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#addOptions"}),"addOptions")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#layoutonresize"}),"propsToData")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#forceSync"}),"forceSync")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#instantLayout"}),"instantLayout"))),Object(l.b)("hr",null),Object(l.b)("h3",{id:"ref"},"ref"),Object(l.b)("p",null,"The ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://reactjsx.org/docs/refs-and-the-dom.html"}),"ref")," for the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/haltu/muuri"}),"Muuri")," instance used inside the MuuriComponent. See more ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/muuri"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"React.RefObject"),", ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"const muuriRef = useRef();\n\n<MuuriComponent ref={muuriRef} />;\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent ref={function (grid) {}} />\n")),Object(l.b)("h3",{id:"id"},"id"),Object(l.b)("p",null,"The id of the MuuriComponent."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"string"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent id={"id"} />\n')),Object(l.b)("h3",{id:"groupids"},"groupIds"),Object(l.b)("p",null,"The ids of the ",Object(l.b)("em",{parentName:"p"},"virtual")," groups to which the MuuriComponent belongs, it is possible to change them in any render. This option is used ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#dragsort"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"string[]"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent groupIds={["GroupA", "GroupB"]} />\n')),Object(l.b)("h3",{id:"gridprops"},"gridProps"),Object(l.b)("p",null,"The props of the DOM element generated by the MuuriComponent."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"object"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent gridProps={{ className: "grid" }} />\n')),Object(l.b)("h3",{id:"dragenabled"},"dragEnabled"),Object(l.b)("p",null,"Should Items be draggable?"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: boolean.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent dragEnabled={true} />\n")),Object(l.b)("h3",{id:"filter"},"filter"),Object(l.b)("p",null,"The filter function is executed for every Item in the instance. If the return value of the predicate is truthy the Item in question will be shown and otherwise hidden. The function receives the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/items-data.md"}),"data")," of the Item as its argument. ",Object(l.b)("br",null),"\nRemember to provide a memoized value to avoid useless re-filtering (as the component will re-filter each time the value change). See more ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/filtering-&-sorting?id=filtering"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"const filter = useCallback(itemData => {\n  // Show only the items that respect the condition.\n  return itemData.someData === 'someValue'\n}, [])\n\n<MuuriComponent\n  filter={filter}\n/>\n")),Object(l.b)("h3",{id:"sort"},"sort"),Object(l.b)("p",null,"There are two ways to sort the Items based on their data. The first is simply by providing a function as the comparer, which will receive the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/items-data"}),"data")," of two Items to compare as arguments. It works almost identically to native array sort, the only difference is that the sort is always stable. Alternatively you can sort by the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/items-data"}),"data")," you have provided for the Items. Just provide the data key(s) as a string (separated by space) and the Items will be sorted based on the provided data keys. ",Object(l.b)("br",null),"\nIf you are using a function, remember to provide a memoized value to avoid useless re-sorting (as the component will re-sort each time the value change). There are two other ways that are not based on data, the first is to provide an ordered list of Items ",Object(l.b)("inlineCode",{parentName:"p"},"keys"),", or to use a ",Object(l.b)("inlineCode",{parentName:"p"},"Token")," that represents a sorting of the Items at a specific time. See more ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/filtering-&-sorting?id=sorting"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"string"),", ",Object(l.b)("inlineCode",{parentName:"li"},"function"),", ",Object(l.b)("inlineCode",{parentName:"li"},"array"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"const sort = useCallback((dataItemA, dataItemB) => {\n  // Sort by id.\n  return dataItemA.id - dataItemB.id\n}, [])\n\n<MuuriComponent\n  propsToData={({ id }) => ({ id })}\n  sort={sort}\n/>\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  propsToData={({ id, tag }) => ({ id, tag })}\n  {/* Sort by id and by tag */}\n  sort={'id tag'}\n/>\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  propsToData={({ id, tag }) => ({ id, tag })}\n  {/* Sort some keys ascending and some keys descending */}\n  sort={'id tag:desc'}\n/>\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'const [sort] = useState(["2", "1"])\n\n<MuuriComponent\n  sort={sort}\n>\n  <Item key={"1"} />\n  <Item key={"2"} />\n</MuuriComponent>\n')),Object(l.b)("h3",{id:"sortoptions"},"sortOptions"),Object(l.b)("p",null,"With this options you can change the sorting order (default ascending). ",Object(l.b)("br",null),"\nRemember to provide a memoized value to avoid useless re-sorting (as the component will re-sort each time the value change)."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"object"),"."),Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{ descending: false }"))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'const [sort] = useState({\n  value: "id",\n  options: { descending: true }\n})\n\n<MuuriComponent\n  sort={sort.value}\n  sortOptions={sort.options}\n/>\n')),Object(l.b)("h3",{id:"addoptions"},"addOptions"),Object(l.b)("p",null,"With this options you can decide how the MuuriComponent will manage the new Items added with the CSS display property set to ",Object(l.b)("inlineCode",{parentName:"p"},"none"),", If show is true the Item will be added with a showing animation, otherwise the Item will be hidden. Note that if the filter props is set it takes precedence over the decision of which Items are visible or not."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"object"),"."),Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{ show: true }"))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent addOptions={{ show: false }} />\n")),Object(l.b)("h3",{id:"propstodata"},"propsToData"),Object(l.b)("p",null,"The function is executed for each Item in the instance. The returned object will represent the data of the Item in question. The function receives the props of the Item as its argument. See more ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/items-data"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"const items = [{ id: 1 }, { id: 2 }]\nconst children = items.map(({ id }) => <Item id={id} />)\n\n// The id prop will be used as data.\n<MuuriComponent\n  propsToData={({ id }) => ({ id })}\n>\n  {children}\n</MuuriComponent>\n")),Object(l.b)("h3",{id:"forcesync"},"forceSync"),Object(l.b)("p",null,"Sorting and filtering are not reapplied with a new rendering if their value does not change. If forceSync is true, they will be reapplied even if their values \u200b\u200bhave not changed."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"boolean"),"."),Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent forceSync />\n")),Object(l.b)("h3",{id:"instantlayout"},"instantLayout"),Object(l.b)("p",null,"If true the Items will be positioned instantly without any animation."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"boolean"),"."),Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent instantLayout />\n")),Object(l.b)("h2",{id:"layout-props-\ufe0f"},"Layout props \u2699\ufe0f"),Object(l.b)("p",null,"These are the props that determine how the MuuriComponent will ",Object(l.b)("inlineCode",{parentName:"p"},"work"),", from layout up to the speed of animations. These props can only be chosen when the component is mounted, modifying them in subsequent renders will have no effect."),Object(l.b)("h3",{id:"default-values"},"Default values"),Object(l.b)("p",null,"The default options are stored in ",Object(l.b)("inlineCode",{parentName:"p"},"MuuriComponent.defaultProps")," object, which in it's default state contains the following configuration:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  {/* Default show animation */}\n  showDuration={300}\n  showEasing={'ease'}\n\n  {/* Default hide animation */}\n  hideDuration={300}\n  hideEasing={'ease'}\n\n  {/* Item's visible/hidden state styles */}\n  visibleStyles={{\n    opacity: '1',\n    transform: 'scale(1)'\n  }}\n  hiddenStyles={{\n    opacity: '0',\n    transform: 'scale(0.5)'\n  }}\n\n  {/* Layout */}\n  layout={{\n    fillGaps: false,\n    horizontal: false,\n    alignRight: false,\n    alignBottom: false,\n    rounding: true\n  }}\n  layoutOnResize={100}\n  layoutDuration={300}\n  layoutEasing={'ease'}\n\n  {/* Drag & Drop */}\n  dragContainer={null}\n  dragHandle={null}\n  dragFixed={false}\n  dragStartPredicate={{\n    distance: 0,\n    delay: 0\n  }}\n  dragAxis={null}\n  dragSort={true}\n  dragSortHeuristics={{\n    sortInterval: 100,\n    minDragDistance: 10,\n    minBounceBackAngle: 1\n  }}\n  dragSortPredicate={{\n    threshold: 50,\n    action: 'move',\n    migrateAction: 'move'\n  }}\n  dragRelease={{\n    duration: 300,\n    easing: 'ease',\n    useDragContainer: true\n  }}\n  dragCssProps={{\n    touchAction: 'none',\n    userSelect: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0, 0, 0, 0)',\n    touchCallout: 'none',\n    contentZooming: 'none'\n  }}\n  dragPlaceholder={{\n    enabled: false,\n    createElement: null,\n    onCreate: null,\n    onRemove: null\n  }}\n  dragAutoScroll={{\n    targets: [],\n    handle: null,\n    threshold: 50,\n    safeZone: 0.2,\n    speed: MuuriReact.AutoScroller.smoothSpeed(1000, 2000, 2500),\n    sortDuringScroll: true,\n    syncAfterScroll: true,\n    smoothStop: true,\n    onStart: null,\n    onStop: null\n  }}\n\n  {/* Classnames */}\n  containerClass={'muuri'}\n  itemClass={'muuri-item'}\n  itemVisibleClass={'muuri-item-shown'}\n  itemHiddenClass={'muuri-item-hidden'}\n  itemPositioningClass={'muuri-item-positioning'}\n  itemDraggingClass={'muuri-item-dragging'}\n  itemReleasingClass={'muuri-item-releasing'}\n  itemPlaceholderClass={'muuri-item-placeholder'}\n/>\n")),Object(l.b)("p",null,"You can modify the default options easily:"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'MuuriComponent.defaultOptions.showDuration = 400;\nMuuriComponent.defaultOptions.dragSortPredicate.action = "swap";\n')),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#showduration"}),"showDuration")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#showeasing"}),"showEasing")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#hideduration"}),"hideDuration")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#hideeasing"}),"hideEasing")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#visiblestyles"}),"visibleStyles")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#hiddenstyles"}),"hiddenStyles")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#layout"}),"layout")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#layoutonresize"}),"layoutOnResize")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#layoutduration"}),"layoutDuration")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#layouteasing"}),"layoutEasing")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragFixed"}),"dragFixed")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragcontainer"}),"dragContainer")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragHandle"}),"dragHandle")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragstartpredicate"}),"dragStartPredicate")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragaxis"}),"dragAxis")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragsort"}),"dragSort")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragsortheuristics"}),"dragSortHeuristics")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragsortpredicate"}),"dragSortPredicate")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragrelease"}),"dragRelease")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragcssprops"}),"dragCssProps")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragplaceholder"}),"dragPlaceholder")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#dragAutoScroll"}),"dragAutoScroll")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#containerclass"}),"containerClass")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#itemclass"}),"itemClass")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#itemvisibleclass"}),"itemVisibleClass")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#itemhiddenclass"}),"itemHiddenClass")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#itempositioningclass"}),"itemPositioningClass")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#itemdraggingclass"}),"itemDraggingClass")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#itemreleasingclass"}),"itemReleasingClass")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#itemplaceholderclass"}),"itemPlaceholderClass"))),Object(l.b)("hr",null),Object(l.b)("h3",{id:"showduration"},"showDuration"),Object(l.b)("p",null,"Show animation duration in milliseconds. Set to ",Object(l.b)("inlineCode",{parentName:"p"},"0")," to disable show animation."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"300"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: number.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent showDuration={600} />\n")),Object(l.b)("h3",{id:"showeasing"},"showEasing"),Object(l.b)("p",null,"Show animation easing. Accepts any valid ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing"}),"Animation easing")," value."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'ease'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent showEasing={"cubic-bezier(0.215, 0.61, 0.355, 1)"} />\n')),Object(l.b)("h3",{id:"hideduration"},"hideDuration"),Object(l.b)("p",null,"Hide animation duration in milliseconds. Set to ",Object(l.b)("inlineCode",{parentName:"p"},"0")," to disable hide animation."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"300"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: number.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent hideDuration={600} />\n")),Object(l.b)("h3",{id:"hideeasing"},"hideEasing"),Object(l.b)("p",null,"Hide animation easing. Accepts any valid ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing"}),"Animation easing")," value."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'ease'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent hideEasing={"cubic-bezier(0.215, 0.61, 0.355, 1)"} />\n')),Object(l.b)("h3",{id:"visiblestyles"},"visibleStyles"),Object(l.b)("p",null,"The styles that will be applied to all visible Items. These styles are also used for the show/hide animations which means that you have to have the same style properties in visibleStyles and hiddenStyles options. Be sure to define all style properties camel cased."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{opacity: 1, transform: 'scale(1)'}"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: object.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent\n  visibleStyles={{\n    opacity: 1,\n    transform: "rotate(45deg)"\n  }}\n  hiddenStyles={{\n    opacity: 0,\n    transform: "rotate(-45deg)"\n  }}\n/>\n')),Object(l.b)("h3",{id:"hiddenstyles"},"hiddenStyles"),Object(l.b)("p",null,"The styles that will be applied to all hidden Items. These styles are also used for the show/hide animations which means that you have to have the same style properties in visibleStyles and hiddenStyles options. Be sure to define all style properties camel cased."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{opacity: 0, transform: 'scale(0.5)'}"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: object.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent\n  visibleStyles={{\n    opacity: 1,\n    transform: "rotate(45deg)"\n  }}\n  hiddenStyles={{\n    opacity: 0,\n    transform: "rotate(-45deg)"\n  }}\n/>\n')),Object(l.b)("h3",{id:"layout"},"layout"),Object(l.b)("p",null,"Define how the Items will be positioned. Muuri ships with a configurable layout algorithm which is used by default. It's pretty flexible and suitable for most common situations (lists, grids and even bin packed grids). If that does not fit the bill you can always provide your own layout algorithm (it's not as scary as it sounds)."),Object(l.b)("p",null,"Muuri supports calculating the layout both synchronously and asynchronously. By default (if you use the default layout algorithm) Muuri will use two shared web workers to compute the layouts asynchronously. In browsers that do not support web workers Muuri will fallback to synchronous layout calculations."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{fillGaps: false, horizontal: false, alignRight: false, alignBottom: false, rounding: false }"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: function, object.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Provide an ",Object(l.b)("em",{parentName:"strong"},"object")," to configure the default layout algorithm with the following properties")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"fillGaps")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"When ",Object(l.b)("inlineCode",{parentName:"li"},"true")," the algorithm goes through every Item in order and places each Item to the first available free slot, even if the slot happens to be visually ",Object(l.b)("em",{parentName:"li"},"before")," the previous element's slot. Practically this means that the Items might not end up visually in order, but there will be less gaps in the grid."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"horizontal")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"When ",Object(l.b)("inlineCode",{parentName:"li"},"true")," the grid works in landscape mode (grid expands to the right). Use for horizontally scrolling sites. When ",Object(l.b)("inlineCode",{parentName:"li"},"false"),' the grid works in "portrait" mode and expands downwards.'))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"alignRight")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"When ",Object(l.b)("inlineCode",{parentName:"li"},"true")," the Items are aligned from right to left."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"alignBottom")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"When ",Object(l.b)("inlineCode",{parentName:"li"},"true")," the Items are aligned from the bottom up."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"rounding")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"When ",Object(l.b)("inlineCode",{parentName:"li"},"true")," the dimensions of the Items will be automatically rounded for the layout calculations using ",Object(l.b)("inlineCode",{parentName:"li"},"Math.round()"),". Set to ",Object(l.b)("inlineCode",{parentName:"li"},"false")," to use accurate dimensions. In practice you would want disable this if you are using relative dimension values for Items (%, em, rem, etc.). If you have defined Item dimensions with pixel values (px) it is recommended that you leave this on.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Customize the default layout algorithm.\n<MuuriComponent\n  layout={{\n    fillGaps: true,\n    horizontal: true,\n    alignRight: true,\n    alignBottom: true,\n    rounding: true\n  }}\n>\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Provide a ",Object(l.b)("em",{parentName:"strong"},"function")," to use a custom layout algorithm")),Object(l.b)("p",null,"When you provide a custom layout function Muuri calls it whenever calculation of layout is necessary. Before calling the layout function Muuri always calculates the current width and height of the grid's container element and also creates an array of all the Items that are part of the layout currently (all ",Object(l.b)("em",{parentName:"p"},"active")," Items)."),Object(l.b)("p",null,"The layout function always receives the following arguments:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"grid")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The grid that requested the layout."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"layoutId")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Automatically generated unique id for the layout which is used to keep track of the layout requests and to make sure that the correct layout gets applied at correct time."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"items")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Array of ",Object(l.b)("inlineCode",{parentName:"li"},"Muuri.Item")," instances. A new array instance is created for each layout so there's no harm in manipulating this if you need to (or using it as is for the layout data object)."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"width")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Current width (in pixels) of the grid element (excluding borders, but including padding)."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"height")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Current height (in pixels) of the grid element (excluding borders, but including padding)."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"callback")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"function"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"When the layout is calculated and ready to be applied you need to call this callback function and provide a ",Object(l.b)("em",{parentName:"li"},"layout object")," as its argument. Note that if another layout is requesteded while the current layout is still being calculated (asynchronously) this layout will be ignored.")))),Object(l.b)("p",null,"If the layout function's calculations are asynchronous you can optionally return a cancel function, which Muuri will call if there is a new layout request before the current layout has finished it's calculations."),Object(l.b)("p",null,"The layout object, which needs to be provided to the callback, must include the following properties."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"id")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The layout's unique id (must be the ",Object(l.b)("inlineCode",{parentName:"li"},"layoutId")," provided by Muuri)."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"items")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Array of the active Item instances that are part of the layout. You can pass the same ",Object(l.b)("inlineCode",{parentName:"li"},"items")," array here which is provided by Muuri (in case you haven't mutated it). This array Items must be identical to the array of Items provided by Muuri."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"slots")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Array of the Item positions (numbers). E.g. if the Items were ",Object(l.b)("inlineCode",{parentName:"li"},"[a, b]")," this should be ",Object(l.b)("inlineCode",{parentName:"li"},"[aLeft, aTop, bLeft, bTop]"),". You have to calculate the ",Object(l.b)("inlineCode",{parentName:"li"},"left")," and ",Object(l.b)("inlineCode",{parentName:"li"},"top")," position for each Item in the provided ",Object(l.b)("em",{parentName:"li"},"items")," array in the same order the Items are provided."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"styles")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"object / null"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Here you can optionally define all the layout related CSS styles that should be applied to the grid element ",Object(l.b)("em",{parentName:"li"},"just")," before the ",Object(l.b)("inlineCode",{parentName:"li"},"layoutStart")," event is emitted. E.g. ",Object(l.b)("inlineCode",{parentName:"li"},"{width: '100%', height: '200px', minWidth: '200px'}"),"."),Object(l.b)("li",{parentName:"ul"},"It's important to keep in mind here that if the grid element's ",Object(l.b)("inlineCode",{parentName:"li"},"box-sizing")," CSS property is set to ",Object(l.b)("inlineCode",{parentName:"li"},"border-box")," the element's borders are included in the dimensions. E.g. if you set ",Object(l.b)("inlineCode",{parentName:"li"},"{width: '100px', width: '100px'}")," here and the element has a ",Object(l.b)("inlineCode",{parentName:"li"},"5px")," border and ",Object(l.b)("inlineCode",{parentName:"li"},"box-sizing")," is set to ",Object(l.b)("inlineCode",{parentName:"li"},"border-box"),", then the ",Object(l.b)("em",{parentName:"li"},"layout's")," effective ",Object(l.b)("inlineCode",{parentName:"li"},"width")," and ",Object(l.b)("inlineCode",{parentName:"li"},"height")," (as perceived by Muuri) will be ",Object(l.b)("inlineCode",{parentName:"li"},"90px"),". So remember to take that into account and add the borders to the dimensions when necessary. If this sounds complicated then just don't set borders directly to the grid element or make sure that grid element's ",Object(l.b)("inlineCode",{parentName:"li"},"box-sizing")," is set to ",Object(l.b)("inlineCode",{parentName:"li"},"content-box")," (which is the default value).")))),Object(l.b)("p",null,"Note that you can add additional properties to the layout object if you wish, e.g. the default layout algorithm also stores the layout's width and height (in pixels) to the layout object."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Build your own layout algorithm.\n<MuuriComponent\n  layout={function (grid, layoutId, items, width, height, callback) {\n    var layout = {\n      id: layoutId,\n      items: items,\n      slots: [],\n      styles: {}\n    };\n\n    // Calculate the slots asynchronously. Note that the timeout is here only\n    // as an example and does not help at all in the calculations. You should\n    // offload the calculations to web workers if you want real benefits.\n    // Also note that doing asynchronous layout is completely optional and you\n    // can call the callback function synchronously also.\n    var timerId = window.setTimeout(function () {\n      var item, m, x = 0, y = 0, w = 0, h = 0;\n\n      for (var i = 0; i < items.length; i++) {\n        item = items[i];\n        x += w;\n        y += h;\n        m = item.getMargin();\n        w = item.getWidth() + m.left + m.right;\n        h = item.getHeight() + m.top + m.bottom;\n        layout.slots.push(x, y);\n      }\n\n      w += x;\n      h += y;\n      // Set the CSS styles that should be applied to the grid element.\n      layout.styles.width = w + 'px';\n      layout.styles.height = h + 'px';\n\n      // When the layout is fully computed let's call the callback function and\n      // provide the layout object as its argument.\n      callback(layout);\n    }, 200);\n\n    // If you are doing an async layout you _can_ (if you want to) return a\n    // function that cancels this specific layout calculations if it's still\n    // processing/queueing when the next layout is requested.\n    return function () {\n      window.clearTimeout(timerId);\n    };\n  }}\n>\n")),Object(l.b)("h3",{id:"layoutonresize"},"layoutOnResize"),Object(l.b)("p",null,"Should Muuri automatically trigger ",Object(l.b)("inlineCode",{parentName:"p"},"layout")," method on window resize? Set to ",Object(l.b)("inlineCode",{parentName:"p"},"false")," to disable. When a number or ",Object(l.b)("inlineCode",{parentName:"p"},"true")," is provided Muuri will automatically position the Items every time window is resized. The provided number (",Object(l.b)("inlineCode",{parentName:"p"},"true")," is transformed to ",Object(l.b)("inlineCode",{parentName:"p"},"0"),") equals to the amount of time (in milliseconds) that is waited before Items are positioned after each window resize event."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"150"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: boolean, number.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// No layout on resize.\n<MuuriComponent\n  layoutOnResize={false}\n>\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Layout on resize (instantly).\n<MuuriComponent\n  layoutOnResize\n>\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Layout on resize (with 200ms debounce).\n<MuuriComponent\n  layoutOnResize={200}\n>\n")),Object(l.b)("h3",{id:"layoutduration"},"layoutDuration"),Object(l.b)("p",null,"The duration for Item's layout animation in milliseconds. Set to ",Object(l.b)("inlineCode",{parentName:"p"},"0")," to disable."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"300"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: number.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent layoutDuration={600} />\n")),Object(l.b)("h3",{id:"layouteasing"},"layoutEasing"),Object(l.b)("p",null,"The easing for Item's layout animation. Accepts any valid ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffectTimingProperties/easing"}),"Animation easing")," value."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'ease'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent layoutEasing={"cubic-bezier(0.215, 0.61, 0.355, 1)"} />\n')),Object(l.b)("h3",{id:"dragfixed"},"dragFixed"),Object(l.b)("p",null,"Should the CSS width, height and padding-top properties of the element be temporarily fixed when dragging? See more ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/items-dimensions?id=drag-%E2%9C%8B"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: boolean.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent dragFixed />\n")),Object(l.b)("h3",{id:"dragcontainer"},"dragContainer"),Object(l.b)("p",null,"The element (or its ref) the dragged Item should be appended to for the duration of the drag. If set to ",Object(l.b)("inlineCode",{parentName:"p"},"null")," (which is also the default value) the MuuriComponent element will be used."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: React.RefObject, element, null.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent dragContainer={document.body} />\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'const ref = useRef();\n\n<div className={"dragContainer"} ref={ref}>\n  <MuuriComponent dragContainer={ref} />\n</div>;\n')),Object(l.b)("h3",{id:"draghandle"},"dragHandle"),Object(l.b)("p",null,"The element within the Item element that should be used as the drag handle. This should be a CSS selector which will be fed to ",Object(l.b)("inlineCode",{parentName:"p"},"element.querySelector()")," as is to obtain the handle element when the Item is instantiated. If no valid element is found or if this is ",Object(l.b)("inlineCode",{parentName:"p"},"null")," Muuri will use the Item element as the handle."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: null."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string, null.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent dragHandle={".handle"} />\n')),Object(l.b)("h3",{id:"dragstartpredicate"},"dragStartPredicate"),Object(l.b)("p",null,"A function that determines when the Item should start to move when the Item is being dragged. By default uses the built-in predicate which has some configurable options."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{distance: 0, delay: 0}"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: function, object.")),Object(l.b)("p",null,"If an object is provided the default sort predicate handler will be used. You can define the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"distance"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"0"),"."),Object(l.b)("li",{parentName:"ul"},"How many pixels must be dragged before the dragging starts."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"delay"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"0"),"."),Object(l.b)("li",{parentName:"ul"},"How long (in milliseconds) the user must drag before the dragging starts.")))),Object(l.b)("p",null,"If you provide a function you can totally customize the drag start logic. When the user starts to drag an Item this predicate function will be called until you return ",Object(l.b)("inlineCode",{parentName:"p"},"true")," or ",Object(l.b)("inlineCode",{parentName:"p"},"false"),". If you return ",Object(l.b)("inlineCode",{parentName:"p"},"true")," the Item will begin to move whenever the Item is dragged. If you return ",Object(l.b)("inlineCode",{parentName:"p"},"false")," the Item will not be moved at all. Note that after you have returned ",Object(l.b)("inlineCode",{parentName:"p"},"true")," or ",Object(l.b)("inlineCode",{parentName:"p"},"false")," this function will not be called until the Item is released and dragged again. Remember that you can enable / disable drag and drop for the single Item with the ",Object(l.b)("inlineCode",{parentName:"p"},"useDraggable")," hook."),Object(l.b)("p",null,"The predicate function receives two arguments:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The Item that's being dragged."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"event"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"object"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The drag event (Muuri.Dragger event).")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Configure the default predicate.\n<MuuriComponent\n  dragStartPredicate={{\n    distance: 10,\n    delay: 100\n  }}\n/>\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Provide your own predicate.\n<MuuriComponent\n  dragStartPredicate={function (item, e) {\n    // Start moving the item after the item has been dragged for one second.\n    if (e.deltaTime > 1000) {\n      return true;\n    }\n  }}\n/>\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Provide your own predicate.\n<MuuriComponent\n  dragStartPredicate={function (item, e) {\n    const key = item.getKey();\n    const data = item.getData();\n\n    // Implement your logic...\n  }}\n/>\n")),Object(l.b)("h3",{id:"dragaxis"},"dragAxis"),Object(l.b)("p",null,"Force Items to be moved only vertically or horizontally when dragged. Set to ",Object(l.b)("inlineCode",{parentName:"p"},"'x'")," for horizontal movement and to ",Object(l.b)("inlineCode",{parentName:"p"},"'y'")," for vertical movement. By default Items can be dragged both vertically and horizontally."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'xy'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string."),Object(l.b)("li",{parentName:"ul"},"Allowed values: ",Object(l.b)("inlineCode",{parentName:"li"},"'x'"),", ",Object(l.b)("inlineCode",{parentName:"li"},"'y'"),", ",Object(l.b)("inlineCode",{parentName:"li"},"'xy'"),".")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'// Move items only horizontally when dragged.\n<MuuriComponent dragAxis={"x"} />\n')),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'// Move items only vertically when dragged.\n<MuuriComponent dragAxis={"y"} />\n')),Object(l.b)("h3",{id:"dragsort"},"dragSort"),Object(l.b)("p",null,"Should the Items be sorted during drag? A simple boolean will do just fine here."),Object(l.b)("p",null,"Alternatively you can do some advanced stuff and control within which MuuriComponents a specific Item can be sorted and dragged into. To do that you can simply provide the groupId of these Muuricomponents. If you want to implement a more complex logic, different for each Item, you can provide a function which receives the dragged Item as its first argument and should return an array of grids. See more ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/reparenting"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"true"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: boolean, object, function.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Disable drag sorting.\n<MuuriComponent dragSort={false} />\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"// Enable it only in the MuuriComponent parent.\n<MuuriComponent dragSort={true} />\n")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'// Enable it only among MuuriComponents of a certain group.\n<MuuriComponent groupIds={["GroupA"]} dragSort={{ groupId: "GroupA" }} />\n')),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'import { muuriMap } from "muuri-react";\n\n// Custom logic.\n<MuuriComponent\n  id={"id"}\n  groupIds={["groupId"]}\n  dragSort={(item) => {\n    // Dragged component.\n    const key = item.getKey();\n    const data = item.getData();\n\n    // Some Muuri instances.\n    const currentGrid = item.getGrid();\n    const gridsArray = muuriMap.getGroup("groupId");\n    const grid = muuriMap.get("id");\n\n    // Implement your logic...\n    // Return an array of Muuri instances into\n    // which the item can be dragged and sorted.\n\n    return anArrayOfGrids;\n  }}\n/>;\n')),Object(l.b)("h3",{id:"dragsortheuristics"},"dragSortHeuristics"),Object(l.b)("p",null,"Defines various heuristics so that sorting during drag would be smoother and faster."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{sortInterval: 100, minDragDistance: 10, minBounceBackAngle: 1}"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: object.")),Object(l.b)("p",null,"You can define the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"sortInterval"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"100"),"."),Object(l.b)("li",{parentName:"ul"},"Defines the amount of time the dragged Item must be still before ",Object(l.b)("inlineCode",{parentName:"li"},"dragSortPredicate")," function is called."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"minDragDistance"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"10"),"."),Object(l.b)("li",{parentName:"ul"},"Defines how much (in pixels) the Item must be dragged before ",Object(l.b)("inlineCode",{parentName:"li"},"dragSortPredicate")," can be called."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"minBounceBackAngle"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"1"),"."),Object(l.b)("li",{parentName:"ul"},"Defines the minimum angle (in radians) of the delta vector between the last movement vector and the current movement vector that is required for the dragged Item to be allowed to be sorted to it's previous index. The problem this heuristic is trying to solve is the scenario where you drag an Item over a much bigger Item and the bigger Item moves, but it's still overlapping the dragged Item after repositioning. Now when you move the dragged Item again another sort is triggered and the bigger Item moves back to it's previous position. This bouncing back and forth can go on for quite a while and it looks quite erratic. The fix we do here is that, by default, we disallow an Item to be moved back to it's previous position, unless it's drag direction changes enough. And what is enough? That's what you can define here. Note that this option works in tandem with ",Object(l.b)("inlineCode",{parentName:"li"},"minDragDistance")," and needs it to be set to ",Object(l.b)("inlineCode",{parentName:"li"},"3")," at minimum to be enabled at all.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  dragEnabled={true}\n  dragSortHeuristics={{\n    sortInterval: 10,\n    minDragDistance: 5,\n    minBounceBackAngle: Math.PI / 2\n  }}\n/>\n")),Object(l.b)("h3",{id:"dragsortpredicate"},"dragSortPredicate"),Object(l.b)("p",null,"Defines the logic for the sort procedure during dragging an Item."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{action: 'move', migrateAction: 'move', threshold: 50}"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: function, object.")),Object(l.b)("p",null,"If an object is provided the default sort predicate handler will be used. You can define the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"action"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'move'"),"."),Object(l.b)("li",{parentName:"ul"},"Allowed values: ",Object(l.b)("inlineCode",{parentName:"li"},"'move'"),", ",Object(l.b)("inlineCode",{parentName:"li"},"'swap'"),"."),Object(l.b)("li",{parentName:"ul"},"Should the dragged Item be ",Object(l.b)("em",{parentName:"li"},"moved")," to the new position or should it ",Object(l.b)("em",{parentName:"li"},"swap")," places with the Item it overlaps?"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"migrateAction"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'move'"),"."),Object(l.b)("li",{parentName:"ul"},"Allowed values: ",Object(l.b)("inlineCode",{parentName:"li"},"'move'"),", ",Object(l.b)("inlineCode",{parentName:"li"},"'swap'"),"."),Object(l.b)("li",{parentName:"ul"},"Should the dragged Item be ",Object(l.b)("em",{parentName:"li"},"moved")," to the new position or should it ",Object(l.b)("em",{parentName:"li"},"swap")," places with the Item it overlaps when the dragged Item is moved to another grid?"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"threshold"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"50"),"."),Object(l.b)("li",{parentName:"ul"},"Allowed values: ",Object(l.b)("inlineCode",{parentName:"li"},"1")," - ",Object(l.b)("inlineCode",{parentName:"li"},"100"),"."),Object(l.b)("li",{parentName:"ul"},"How many percent the intersection area between the dragged Item and the compared Item should be from the maximum potential intersection area between the Items before sorting is triggered.")))),Object(l.b)("p",null,"Alternatively you can provide your own callback function where you can define your own custom sort logic. The callback function receives two arguments:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The Item that's being dragged."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"event"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"object"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The drag event (Muuri.Dragger event).")))),Object(l.b)("p",null,"The callback should return a ",Object(l.b)("em",{parentName:"p"},"falsy")," value if sorting should not occur. If, however, sorting should occur the callback should return an object containing the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"index"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The index where the Item should be moved to."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"grid"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The grid where the Item should be moved to."),Object(l.b)("li",{parentName:"ul"},"Defaults to the Item's current grid."),Object(l.b)("li",{parentName:"ul"},"Optional."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"action"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The movement method."),Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'move'"),"."),Object(l.b)("li",{parentName:"ul"},"Allowed values: ",Object(l.b)("inlineCode",{parentName:"li"},"'move'")," or ",Object(l.b)("inlineCode",{parentName:"li"},"'swap'"),"."),Object(l.b)("li",{parentName:"ul"},"Optional.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'// Customize the default predicate.\n<MuuriComponent\n  dragSortPredicate={{\n    threshold: 90,\n    action: "swap"\n  }}\n/>\n')),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'// Provide your own predicate.\n<MuuriComponent\n  dragSortPredicate={function (item, e) {\n    if (e.deltaTime < 1000) return false;\n    return {\n      index: Math.round(e.deltaTime / 1000) % 2 === 0 ? -1 : 0,\n      action: "swap"\n    };\n  }}\n/>\n')),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"import { ItemDrag } from 'muuri-react'\n\n// Pro tip: use the default predicate as fallback in your custom predicate.\n<MuuriComponent\n  dragSortPredicate={function (item, e) {\n    if (item.getElement().classList.contains('no-sort')) return false;\n    return ItemDrag.defaultSortPredicate(item, {\n      action: 'swap',\n      threshold: 75\n    />\n  }}\n/>\n")),Object(l.b)("h3",{id:"dragrelease"},"dragRelease"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{ duration: 300, easing: 'ease', useDragContainer: true }"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: object.")),Object(l.b)("p",null,"You can define the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"duration \u2014 ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"300"),"."),Object(l.b)("li",{parentName:"ul"},"The duration for Item's drag release animation. Set to ",Object(l.b)("inlineCode",{parentName:"li"},"0")," to disable."))),Object(l.b)("li",{parentName:"ul"},"easing \u2014 string",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'ease'"),"."),Object(l.b)("li",{parentName:"ul"},"The easing for Item's drag release animation. Accepts any valid ",Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/API/EffectTiming/easing"}),"Animation easing")," value."))),Object(l.b)("li",{parentName:"ul"},"useDragContainer \u2014 ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"true"),"."),Object(l.b)("li",{parentName:"ul"},"If ",Object(l.b)("inlineCode",{parentName:"li"},"true")," the Item element will remain within the ",Object(l.b)("inlineCode",{parentName:"li"},"dragContainer")," for the duration of the release process. Otherwise the Item element will be inserted within the grid element (if not already inside it) at the beginning of the release process.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent\n  dragRelease={{\n    duration: 600,\n    easing: "ease-out",\n    useDragContainer: false\n  }}\n/>\n')),Object(l.b)("h3",{id:"dragcssprops"},"dragCssProps"),Object(l.b)("p",null,"Drag specific CSS properties that Muuri sets to the draggable Item elements. Muuri automatically prefixes the properties before applying them to the element. ",Object(l.b)("inlineCode",{parentName:"p"},"touchAction")," property is required to be always defined, but the other properties are optional and can be omitted by setting their value to an empty string if you want to e.g. define them via CSS only."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{touchAction: 'none', userSelect: 'none', userDrag: 'none', tapHighlightColor: 'rgba(0, 0, 0, 0)', touchCallout: 'none', contentZooming: 'none'}"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: object.")),Object(l.b)("p",null,"You can define the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"touchAction"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'none'"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action"}),"https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action")))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"userSelect"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'none'"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select"}),"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select")),Object(l.b)("li",{parentName:"ul"},"Optional."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"userDrag"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'none'"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"http://help.dottoro.com/lcbixvwm.php"}),"http://help.dottoro.com/lcbixvwm.php")),Object(l.b)("li",{parentName:"ul"},"Optional."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"tapHighlightColor"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'rgba(0, 0, 0, 0)'"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-tap-highlight-color"}),"https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-tap-highlight-color")),Object(l.b)("li",{parentName:"ul"},"Optional."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"touchCallout"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'none'"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-touch-callout"}),"https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-touch-callout")),Object(l.b)("li",{parentName:"ul"},"Optional."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"contentZooming"),"\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'none'"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-content-zooming"}),"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-content-zooming")),Object(l.b)("li",{parentName:"ul"},"Optional.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'// Only set the required touch-action CSS property via the options if you for\n// example want to set the other props via CSS instead.\n<MuuriComponent\n  dragEnabled={true}\n  dragCssProps={{\n    touchAction: "pan-y",\n    userSelect: "",\n    userDrag: "",\n    tapHighlightColor: "",\n    touchCallout: "",\n    contentZooming: ""\n  }}\n/>\n')),Object(l.b)("h3",{id:"dragplaceholder"},"dragPlaceholder"),Object(l.b)("p",null,"If you want a placeholder Item to appear for the duration of an Item's drag & drop procedure you can enable and configure it here. The placeholder animation duration is fetched from the grid's ",Object(l.b)("inlineCode",{parentName:"p"},"layoutDuration")," option and easing from the grid's ",Object(l.b)("inlineCode",{parentName:"p"},"layoutEasing")," option. Note that a special placeholder class is given to all drag placeholders and is customizable via ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"#itemplaceholderclass-"}),"itemPlaceholderClass")," option."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{enabled: false, createElement: null, onCreate: null, onRemove: null}"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: object.")),Object(l.b)("p",null,"You can define the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"enabled")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"false"),"."),Object(l.b)("li",{parentName:"ul"},"Is the placeholder enabled?"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"createElement")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"function / null"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"If defined, this method will be used to create the DOM element that is used for the placeholder. By default a new ",Object(l.b)("inlineCode",{parentName:"li"},"div")," element is created when a placeholder is summoned."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"onCreate")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"function / null"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"An optional callback that will be called after a placeholder is created for an Item."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"onRemove")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"function / null"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"An optional callback that will be called after a placeholder is removed from the grid.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  dragEnabled={true}\n  dragPlaceholder={{\n    enabled: true,\n    createElement: function (item) {\n      return item.getElement().cloneNode(true);\n    }\n  }}\n/>\n")),Object(l.b)("h3",{id:"dragautoscroll"},"dragAutoScroll"),Object(l.b)("p",null,"If you want to trigger scrolling on any element during dragging you can enable and configure it here. By default this feature is disabled. When you use this feature it is ",Object(l.b)("em",{parentName:"p"},"highly")," recommended that you create a ",Object(l.b)("inlineCode",{parentName:"p"},"fixed")," positioned element right under ",Object(l.b)("inlineCode",{parentName:"p"},"document.body")," and use that as the ",Object(l.b)("inlineCode",{parentName:"p"},"dragContainer")," for all the dragged Items. If you don't do this and a dragged Item's parent is auto-scrolled, the dragged Item will potentially grow the scrolled element's scroll area to infinity unintentionally."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"{ targets: [], handle: null, threshold: 50, speed: Autoscroller.smoothSpeed(1000, 2000, 2500), sortDuringScroll: true, syncAfterScroll: true, smoothStop: true, onStart: null, onStop: null }"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: object.")),Object(l.b)("p",null,"You can define the following properties:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"targets")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array / function"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"[]"),"."),Object(l.b)("li",{parentName:"ul"},"Define the DOM elements that should be scrolled during drag. As long as this array is empty there will be no scrolling during drag. To keep it simple you can just provide an array of elements here, in which case Muuri attempts to scroll the elements both vertically and horizontally when possible. If you want more fine-grained control, e.g. scroll an element only on specific axis or prioritize some element over another (handy for cases when there are overlapping elements), you can provide an array of scroll targets (objects). Finally, you can also provide a function which receives the dragged ",Object(l.b)("inlineCode",{parentName:"li"},"item")," instance as its argument and which should return an array of scroll targets (elements/objects). This way you can provide different configurations for different Items."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"scrollTarget")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"object"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"element")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"React.RefObject")," / ",Object(l.b)("em",{parentName:"li"},"element")," / ",Object(l.b)("em",{parentName:"li"},"window"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The DOM element to scroll. It could be a React.RefObject containing the element or the element itself."),Object(l.b)("li",{parentName:"ul"},"Required."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"axis")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Optional. Defaults to scrolling both axes: ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.AXIS_X | Autoscroller.AXIS_Y"),"."),Object(l.b)("li",{parentName:"ul"},"To scroll only x-axis: ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.AXIS_X"),"."),Object(l.b)("li",{parentName:"ul"},"To scroll only y-axis: ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.AXIS_Y"),"."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"priority")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default: ",Object(l.b)("inlineCode",{parentName:"li"},"0"),"."),Object(l.b)("li",{parentName:"ul"},"A dragged Item can only scroll one element horizontally and one element vertically simultaneously. This is an artificial limit to fend off unnecesary complexity, and to avoid awkward situations. In the case where the dragged Item overlaps multiple scrollable elements simultaneously and exceeds their scroll thresholds we pick the one that the dragged Item overlaps most. However, that's not always the best choice. This is where ",Object(l.b)("inlineCode",{parentName:"li"},"priority")," comes in. Here you can manually tell Muuri which element to prefer over another in these scenarios. The element with highest priority ",Object(l.b)("em",{parentName:"li"},"always")," wins the fight, in matches with equal priority we determine the winner by the amount of overlap."),Object(l.b)("li",{parentName:"ul"},"Optional."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"threshold")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number / null"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"If defined (a number is provided), this value will override the default threshold for ",Object(l.b)("em",{parentName:"li"},"this scroll target"),". Otherwise the default threshold will be used."),Object(l.b)("li",{parentName:"ul"},"Optional."))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"handle")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"function / null"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"This property defines size and position of the handle (the rectangle that is compared against the scroll element's threshold). By default (when ",Object(l.b)("inlineCode",{parentName:"li"},"null"),") the dragged element's dimensions and offsets are used. However, you can provide a function which should return an object containing the handle's client offsets in pixels (",Object(l.b)("inlineCode",{parentName:"li"},"left")," and ",Object(l.b)("inlineCode",{parentName:"li"},"top"),") and dimensions in pixels (",Object(l.b)("inlineCode",{parentName:"li"},"width")," and ",Object(l.b)("inlineCode",{parentName:"li"},"height"),"). The function receives the following arguments:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"itemClientX")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"itemClientY")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"itemWidth")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"itemHeight")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"pointerClientX")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"pointerClientY")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number")))),Object(l.b)("li",{parentName:"ul"},"Tip: Use ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.pointerHandle(pointerSize)")," utility method if you want to use the pointer (instead of the element) as the handle."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"threshold")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"50"),"."),Object(l.b)("li",{parentName:"ul"},"Defines the distance (in pixels) from the edge of the scrollable element when scrolling should start, in pixels. If this value is ",Object(l.b)("inlineCode",{parentName:"li"},"0")," the scrolling will start when the dragged element reaches the scrollable element's edge. Do note that Muuri dynamically adjusts the scroll element's ",Object(l.b)("em",{parentName:"li"},"edge")," for the calculations (when needed)."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"safeZone")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"0.2"),"."),Object(l.b)("li",{parentName:"ul"},'Defines the size of the minimum "safe zone" space, an area in the center of the scrollable element that will be guaranteed not trigger scrolling regardless threshold size and the dragged Item size. This value is a percentage of the scrollable element\'s size (width or height depending on the scroll axis), and should be something between ',Object(l.b)("inlineCode",{parentName:"li"},"0")," and ",Object(l.b)("inlineCode",{parentName:"li"},"1"),". So in practice, if you set this to e.g ",Object(l.b)("inlineCode",{parentName:"li"},"0.5")," the safe zone would be 50% of the scrollable element's width and height."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"speed")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number / function"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.smoothSpeed(1000, 2000, 2500)"),"."),Object(l.b)("li",{parentName:"ul"},"Defines the scrolling speed in pixels per second. You can provide either static speed with a ",Object(l.b)("inlineCode",{parentName:"li"},"number")," or dynamic speed with a ",Object(l.b)("inlineCode",{parentName:"li"},"function"),". The function is called before every scroll operation and should return the speed (",Object(l.b)("inlineCode",{parentName:"li"},"number"),", pixels per second) for the next scroll operation. The function receives three arguments:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The dragged ",Object(l.b)("inlineCode",{parentName:"li"},"Muuri.Item")," instance."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"scrollElement")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"element")," / ",Object(l.b)("em",{parentName:"li"},"window"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The scrolled element."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"object"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.direction")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The direction of the scroll, one of the following: ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.LEFT"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.RIGHT"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.UP"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.DOWN"),"."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.threshold")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The current threshold in pixels."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.distance")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The handle rectangle's (as defined in ",Object(l.b)("inlineCode",{parentName:"li"},"handle")," option) current distance from the edge of the scroll element. E.g, if ",Object(l.b)("inlineCode",{parentName:"li"},"direction")," is ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.RIGHT")," then distance is ",Object(l.b)("inlineCode",{parentName:"li"},"scrollElement.getBoundingClientRect().right - handleRect.right"),", and if ",Object(l.b)("inlineCode",{parentName:"li"},"direction")," is ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.LEFT")," then distance is ",Object(l.b)("inlineCode",{parentName:"li"},"handleRect.left - scrollElement.getBoundingClientRect().left"),". Can be a negative value too."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.value")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The scroll element's current scroll value on the scrolled axis."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.maxValue")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The scroll element's maximum scroll value on the scrolled axis."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.duration")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"How long (in milliseconds) this specific auto-scroll operation has lasted so far."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.speed")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The current speed as pixels per second."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.deltaTime")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"requestAnimationFrame"),"'s delta time (in milliseconds)."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"data.isEnding")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Is the scroll process ending? When this is ",Object(l.b)("inlineCode",{parentName:"li"},"true")," it means that the associated drag Item does not satisfy the threshold anymore. You should now start decreasing the speed towards ",Object(l.b)("inlineCode",{parentName:"li"},"0")," to allow the Item to come to rest smoothly."))))))),Object(l.b)("li",{parentName:"ul"},"Pro tip: Use ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.smoothSpeed()")," for dynamic speed that provides a smooth scrolling experience. When executed it creates and returns a speed function which you can directly provide for ",Object(l.b)("inlineCode",{parentName:"li"},"speed")," option. The method ",Object(l.b)("em",{parentName:"li"},"requires")," three arguments (in the following order):",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"maxSpeed")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The maximum speed (pixels per second) when the handle's distance to the scroll target's edge is ",Object(l.b)("inlineCode",{parentName:"li"},"0")," or less."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"acceleration")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"How fast the the speed may accelerate (pixels per second)."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"deceleration")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"How fast the the speed may decelerate (pixels per second)."))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"sortDuringScroll")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"true"),"."),Object(l.b)("li",{parentName:"ul"},"Should the grid Items be sorted during auto-scroll or not?"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"syncAfterScroll")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"true"),"."),Object(l.b)("li",{parentName:"ul"},"Should Muuri automatically update the positions of the dragged Items that were affected by scrolling? If you disable this option and the dragged Item's parent is scrolled, the dragged Item will visually shake during scroll. Unless all of your dragged Items are inside a ",Object(l.b)("inlineCode",{parentName:"li"},"fixed")," positioned container element (which is the recommeded pattern), you should leave this enabled."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"smoothStop")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"boolean"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"true"),"."),Object(l.b)("li",{parentName:"ul"},"When a dragged Item is moved out of the threshold area the scroll process is set to ",Object(l.b)("em",{parentName:"li"},"ending")," state. However, it's up to you to decide if the actual scrolling motion is stopped gradually or instantly. By default, when this is ",Object(l.b)("inlineCode",{parentName:"li"},"true"),", scrolling will continue until speed reaches ",Object(l.b)("inlineCode",{parentName:"li"},"0"),". If you set this to ",Object(l.b)("inlineCode",{parentName:"li"},"false")," scrolling will stop immediately. ",Object(l.b)("em",{parentName:"li"},"Always")," set this to ",Object(l.b)("inlineCode",{parentName:"li"},"false")," is you use static speed. When this option is ",Object(l.b)("inlineCode",{parentName:"li"},"enabled")," you ",Object(l.b)("em",{parentName:"li"},"must")," handle decelerating the speed to ",Object(l.b)("inlineCode",{parentName:"li"},"0")," yourself within speed ",Object(l.b)("inlineCode",{parentName:"li"},"function"),". The default ",Object(l.b)("inlineCode",{parentName:"li"},"speed")," fuction handles the deceleration automatically."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"onStart")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"null / function"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"Optionally, you can provide a callback that will be called when an Item starts auto-scrolling a scroll target. The callback function will receive the following arguments:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The dragged ",Object(l.b)("inlineCode",{parentName:"li"},"Muuri.Item")," instance."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"scrollElement")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"element")," / ",Object(l.b)("em",{parentName:"li"},"window"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The scrolled element."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"direction")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The direction of the scroll, one of the following: ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.LEFT"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.RIGHT"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.UP"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.DOWN"),"."))))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"onStop")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"null / function"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"null"),"."),Object(l.b)("li",{parentName:"ul"},"Optionally, you can provide a callback that will be called when an Item stops auto-scrolling a scroll target. The callback function will receive the following arguments:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The dragged ",Object(l.b)("inlineCode",{parentName:"li"},"Muuri.Item")," instance."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"scrollElement")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"element"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The scrolled element."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"direction")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The direction of the scroll, one of the following: ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.LEFT"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.RIGHT"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.UP"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Autoscroller.DOWN"),".")))))))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'import { AutoScroller } from "muuri-react";\n')),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'const scrollElemRef = useRef();\n\n<div className="scrollContainer" ref={scrollElemRef}>\n  <MuuriComponent\n    dragEnabled\n    dragAutoScroll={{\n      targets: [\n        // Scroll window on both x-axis and y-axis.\n        { element: window, priority: 0 },\n        // Scroll scrollElement (can be any scrollable element) on y-axis only,\n        // and prefer it over window in conflict scenarios.\n        { element: scrollElemRef, priority: 1, axis: AutoScroller.AXIS_Y }\n      ],\n      // Let\'s use the dragged item element as the handle.\n      handle: null,\n      // Start auto-scroll when the distance from scroll target\'s edge to dragged\n      // item is 40px or less.\n      threshold: 40,\n      // Make sure the inner 10% of the scroll target\'s area is always "safe zone"\n      // which does not trigger auto-scroll.\n      safeZone: 0.1,\n      // Let\'s define smooth dynamic speed.\n      // Max speed: 2000 pixels per second\n      // Acceleration: 2700 pixels per second\n      // Deceleration: 3200 pixels per second.\n      speed: AutoScroller.smoothSpeed(2000, 2700, 3200),\n      // Let\'s not sort during scroll.\n      sortDuringScroll: false,\n      // No need to sync dragged item positions after scroll since we place all\n      // the dragged items within a fixed element which does not scroll.\n      syncAfterScroll: false,\n      // Finally let\'s log some data when auto-scroll starts and stops.\n      onStart: function (item, scrollElement, direction) {\n        console.log("AUTOSCROLL STARTED", item, scrollElement, direction);\n      },\n      onStop: function (item, scrollElement, direction) {\n        console.log("AUTOSCROLL STOPPED", item, scrollElement, direction);\n      }\n    }}\n  />\n</div>;\n')),Object(l.b)("h3",{id:"containerclass"},"containerClass"),Object(l.b)("p",null,"Container element's class name."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent containerClass={"foo"} />\n')),Object(l.b)("h3",{id:"itemclass"},"itemClass"),Object(l.b)("p",null,"Item element's class name."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri-item'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent itemClass={"foo-item"} />\n')),Object(l.b)("h3",{id:"itemvisibleclass"},"itemVisibleClass"),Object(l.b)("p",null,"Visible Item's class name."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri-item-shown'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent itemVisibleClass={"foo-item-shown"} />\n')),Object(l.b)("h3",{id:"itemhiddenclass"},"itemHiddenClass"),Object(l.b)("p",null,"Hidden Item's class name."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri-item-hidden'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent itemHiddenClass={"foo-item-hidden"} />\n')),Object(l.b)("h3",{id:"itempositioningclass"},"itemPositioningClass"),Object(l.b)("p",null,"This class name will be added to the Item element for the duration of positioning."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri-item-positioning'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent itemPositioningClass={"foo-item-positioning"} />\n')),Object(l.b)("h3",{id:"itemdraggingclass"},"itemDraggingClass"),Object(l.b)("p",null,"This class name will be added to the Item element for the duration of drag."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri-item-dragging'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent itemDraggingClass={"foo-item-dragging"} />\n')),Object(l.b)("h3",{id:"itemreleasingclass"},"itemReleasingClass"),Object(l.b)("p",null,"This class name will be added to the Item element for the duration of release."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri-item-releasing'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent itemReleasingClass={"foo-item-releasing"} />\n')),Object(l.b)("h3",{id:"itemplaceholderclass"},"itemPlaceholderClass"),Object(l.b)("p",null,"This class name will be added to the drag placeholder element."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Default value: ",Object(l.b)("inlineCode",{parentName:"li"},"'muuri-item-placeholder'"),"."),Object(l.b)("li",{parentName:"ul"},"Accepted types: string.")),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'<MuuriComponent itemPlaceholderClass={"foo-item-placeholder"} />\n')),Object(l.b)("h2",{id:"event-props-\ufe0f"},"Event props \u2699\ufe0f"),Object(l.b)("p",null,"All the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/haltu/muuri#grid-events"}),"events")," can be listened through the ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/muuri"}),"Muuri instance"),". Some events can also be listened through the MuuriComponent props for convenience."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#onSend"}),"onSend")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#ref"}),"onDragStart")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#id"}),"onDragEnd")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#groupIds"}),"onFilter")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#gridProps"}),"onSort")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#onMount"}),"onMount")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",Object(n.a)({parentName:"li"},{href:"#onUnmount"}),"onUnmount"))),Object(l.b)("hr",null),Object(l.b)("h3",{id:"onsend"},"onSend"),Object(l.b)("p",null,"A function called when an Item is transferred from a MuuriComponent to another, if your project use this functionality then it is mandatory to use this property to synchronize the state of the Items with the change. The function will receive the information about the event as its argument as shown in the example above. See more ",Object(l.b)("a",Object(n.a)({parentName:"p"},{href:"../usage/reparenting"}),"here"),"."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.key")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The key of the transferred Item."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.fromId")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The id of the old MuuriComponent."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.fromIndex")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The index of the Item in the old MuuriComponent."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.fromGroupIds")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string[]"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The group ids of the old MuuriComponent."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.fromGrid")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The old Muuri instance."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.toId")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The id of the new MuuriComponent."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.toIndex")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"number"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The index of the Item in the new MuuriComponent."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.toGroupIds")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"string[]"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The group ids of the new MuuriComponent."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"payload.toGrid")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The new Muuri instance.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"const [items, setItems] = useState([])\n\n<MuuriComponent\n  onSend={function({\n    // The key of the transferred item.\n    key,\n    // The id of the old MuuriComponent.\n    fromId,\n    // The id of the new MuuriComponent.\n    toId,\n  }) {\n    // Sync the state.\n  }}\n/>\n")),Object(l.b)("h3",{id:"ondragstart"},"onDragStart"),Object(l.b)("p",null,"Triggered when ",Object(l.b)("inlineCode",{parentName:"p"},"dragging")," of an Item begins."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The dragged Item."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"event")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"object"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"Muuri.Dragger event data.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  onDragStart={function (item, event) {\n    console.log(\n      item.getKey(),\n      item.getData(),\n      item.getGrid(),\n      item.getElement()\n    );\n  }}\n/>\n")),Object(l.b)("h3",{id:"ondragend"},"onDragEnd"),Object(l.b)("p",null,"Triggered when ",Object(l.b)("inlineCode",{parentName:"p"},"dragging")," of an Item ends."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"item")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri.Item"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The dragged Item.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  onDragEnd={function (item) {\n    console.log(\n      item.getKey(),\n      item.getData(),\n      item.getGrid(),\n      item.getElement()\n    );\n  }}\n/>\n")),Object(l.b)("h3",{id:"onfilter"},"onFilter"),Object(l.b)("p",null,"Triggered when the ",Object(l.b)("inlineCode",{parentName:"p"},"filter")," is applied."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"shownItems")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The Items that are shown."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"hiddenItems")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The Items that are hidden.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  onDragEnd={function (shownItems, hiddenItems) {\n    console.log(shownItems);\n    console.log(hiddenItems);\n  }}\n/>\n")),Object(l.b)("h3",{id:"onsort"},"onSort"),Object(l.b)("p",null,"Triggered when the ",Object(l.b)("inlineCode",{parentName:"p"},"sort")," is applied."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"currentOrder")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"All Items in their current order."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"previousOrder")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"array"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"All Items in their previous order.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  onDragEnd={function (currentOrder, previousOrder) {\n    console.log(currentOrder);\n    console.log(previousOrder);\n  }}\n/>\n")),Object(l.b)("h3",{id:"onmount"},"onMount"),Object(l.b)("p",null,"A function that will be called when the component will mount, it receive the Muuri instance as argument."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"grid")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The internal Muuri instance.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent onMount={function (muuri) {}} />\n")),Object(l.b)("h3",{id:"onunmount"},"onUnmount"),Object(l.b)("p",null,"A function that will be called when the component will mount, it receive the Muuri instance as argument."),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Accepted types: ",Object(l.b)("inlineCode",{parentName:"li"},"function"),".")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"grid")," ","\xa0","\u2014","\xa0"," ",Object(l.b)("em",{parentName:"li"},"Muuri"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"The internal Muuri instance.")))),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent onUnmount={function (grid) {}} />\n")))}c.isMDXComponent=!0},140:function(e,t,a){"use strict";a.d(t,"a",(function(){return s})),a.d(t,"b",(function(){return d}));var n=a(0),l=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var c=l.a.createContext({}),u=function(e){var t=l.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):b({},t,{},e)),a},s=function(e){var t=u(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},p=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,r=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),s=u(a),p=n,d=s["".concat(r,".").concat(p)]||s[p]||m[p]||i;return a?l.a.createElement(d,b({ref:t},c,{components:a})):l.a.createElement(d,b({ref:t},c))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,r=new Array(i);r[0]=p;var b={};for(var o in t)hasOwnProperty.call(t,o)&&(b[o]=t[o]);b.originalType=e,b.mdxType="string"==typeof e?e:n,r[1]=b;for(var c=2;c<i;c++)r[c]=a[c];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"}}]);