(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{130:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return u})),n.d(t,"default",(function(){return d}));var r=n(1),o=n(6),a=(n(0),n(140)),i=n(142),s={title:"Reparenting"},c={id:"usage/reparenting",title:"Reparenting",description:'import useBaseUrl from "@docusaurus/useBaseUrl";\r',source:"@site/docs\\usage\\reparenting.mdx",permalink:"/muuri-react/docs/usage/reparenting",editUrl:"https://github.com/paol-imi/muuri-react/edit/master/website/docs/usage/reparenting.mdx",sidebar:"someSidebar",previous:{title:"Hooks \ud83d\udd0c",permalink:"/muuri-react/docs/usage/hooks"},next:{title:"Drag scroll \ud83d\uddb1\ufe0f",permalink:"/muuri-react/docs/usage/drag-scroll"}},u=[{value:"How it works \ud83d\udcd6",id:"how-it-works-",children:[]},{value:"Rules \ud83d\udcdc",id:"rules-",children:[]},{value:"Usage \ud83d\udcd6",id:"usage-",children:[]},{value:"Hook: useGrid \ud83d\udd0c",id:"hook-usegrid-",children:[]},{value:"Exclusive drop \ud83d\udeab",id:"exclusive-drop-",children:[]},{value:"Manual reparenting \ud83d\udc77",id:"manual-reparenting-",children:[]},{value:"How is that possible? \ud83e\udd28",id:"how-is-that-possible-\ud83e\udd28",children:[]}],p={rightToc:u};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"There are ",Object(a.b)("strong",{parentName:"p"},"situations")," were you want to change the MuuriComponent ",Object(a.b)("inlineCode",{parentName:"p"},"parent")," of the dragging Item while a drag is occurring. Here's an example in the gif below."),Object(a.b)("img",{src:Object(i.a)("gifs/kanban.gif"),style:{width:"60%"}}),Object(a.b)("p",null,"The implementation of this feature in ",Object(a.b)("strong",{parentName:"p"},"Muuri-react")," manages to have the following characteristics"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The component is not ",Object(a.b)("inlineCode",{parentName:"li"},"unmounted / re-mounted")," ",Object(a.b)("em",{parentName:"li"},"(best performance)"),"."),Object(a.b)("li",{parentName:"ul"},"Items don't have to be ",Object(a.b)("inlineCode",{parentName:"li"},"configured")," ",Object(a.b)("em",{parentName:"li"},"(very easy to implement)"),"."),Object(a.b)("li",{parentName:"ul"},"The internal ",Object(a.b)("inlineCode",{parentName:"li"},"state")," of the Item is maintained ",Object(a.b)("em",{parentName:"li"},"(best developer experience)"),".")),Object(a.b)("h2",{id:"how-it-works-"},"How it works \ud83d\udcd6"),Object(a.b)("p",null,"There are two types of ",Object(a.b)("strong",{parentName:"p"},"events"),":"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"When the Item is ",Object(a.b)("inlineCode",{parentName:"li"},"dragged")," to another MuuriComponent ",Object(a.b)("em",{parentName:"li"},"(but not released)"),"."),Object(a.b)("li",{parentName:"ul"},"When the Item is ",Object(a.b)("inlineCode",{parentName:"li"},"released")," in another MuuriComponent.")),Object(a.b)("p",null,"You can interact with the first event in the Item via the ",Object(a.b)("inlineCode",{parentName:"p"},"useGrid")," hook. Instead you ",Object(a.b)("strong",{parentName:"p"},"have to")," interact with the second event through the MuuriComponent ",Object(a.b)("inlineCode",{parentName:"p"},"onSend")," prop."),Object(a.b)("p",null,"This division allows you to have the best ",Object(a.b)("strong",{parentName:"p"},"performance")," and a better ",Object(a.b)("strong",{parentName:"p"},"user experience"),". In the example of the gif, you can figure out which grid the Item is on, for changing the color of the right strip, only re-rendering the Item and not all the MuuriComponents."),Object(a.b)("h2",{id:"rules-"},"Rules \ud83d\udcdc"),Object(a.b)("p",null,"There are a few simple ",Object(a.b)("strong",{parentName:"p"},"rules")," for implementing reparenting"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The Items must have unique ",Object(a.b)("inlineCode",{parentName:"li"},"keys")," between them, even if they do not share the same MuuriComponent parent."),Object(a.b)("li",{parentName:"ul"},"You have to choose the MuuriComponents of which the Item can be a child by providing ",Object(a.b)("inlineCode",{parentName:"li"},"group ids"),"."),Object(a.b)("li",{parentName:"ul"},"When an Item changes parent you have to sync the state with the ",Object(a.b)("inlineCode",{parentName:"li"},"onSend")," prop.")),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent\n  onSend={(payload) => {\n    // Sync the state and\n    // Re-render the MuuriComponents...\n  }}\n/>\n")),Object(a.b)("h2",{id:"usage-"},"Usage \ud83d\udcd6"),Object(a.b)("p",null,"let's try to reproduce a part of the code of the example in gif, we focus on writing the ",Object(a.b)("inlineCode",{parentName:"p"},"onSend")," function later."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),'const App = () => {\n  // Items.\n  const [items, setItems] = useState({\n    todo: [{ key: "1", text: "Shopping" }],\n    done: [{ key: "2", text: "Homework" }]\n  });\n\n  // Items to children.\n  const children = {\n    todo: items.todo.map((props) => <Item {...props} />),\n    done: items.done.map((props) => <Item {...props} />)\n  };\n\n  return (\n    <>\n      {/* Items marked as \'todo\' */}\n      <MuuriComponent\n        dragEnabled\n        // The unique id of the MuuriComponent.\n        id={"TODO"}\n        // The groups of the MuuriComponent.\n        groupIds={["LIST"]}\n        // The item can only be dragged (and sorted) into\n        // MuuriComponents of the group \'LIST\'.\n        dragSort={{ groupId: "LIST" }}\n        // Will be done later.\n        onSend={/* ... */}\n      >\n        {children.todo}\n      </MuuriComponent>\n\n      {/* Items marked as \'done\' */}\n      <MuuriComponent\n        dragEnabled\n        id={"DONE"}\n        groupIds={["LIST"]}\n        dragSort={{ groupId: "LIST" }}\n        onSend={/* ... */}\n      >\n        {children.done}\n      </MuuriComponent>\n    </>\n  );\n};\n')),Object(a.b)("p",null,"When an Item is ",Object(a.b)("inlineCode",{parentName:"p"},"dragged")," to another MuuriComponent as in the gif, we must update the Items state."),Object(a.b)("p",null,"The MuuriComponents must ",Object(a.b)("strong",{parentName:"p"},"re-render")," with their updated children, considering that the Item that has been dragged must be ",Object(a.b)("strong",{parentName:"p"},"inserted")," in the new MuuriComponent of which it is now a child. Let's create the ",Object(a.b)("strong",{parentName:"p"},"onSend")," method for the first MuuriComponent."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),'// ...\n  <MuuriComponent\n    dragEnabled\n    id={"TODO"}\n    groupIds={["LIST"]}\n    dragSort={{ groupId: "LIST" }}\n    onSend={({ key }) => {\n      // The transferred item.\n      const transferredItem = items.todo.find(item => item.key === key);\n      // Update the items categories.\n      const todo = items.done.filter(item => item !== transferredItem);\n      const done = items.todo.concat(transferredItem);\n\n      // Set the new state.\n      setItems({ todo, done });\n    }}\n  >\n')),Object(a.b)("p",null,"It is possible to ",Object(a.b)("strong",{parentName:"p"},"simply")," insert the Item at the bottom as the last component (",Object(a.b)("inlineCode",{parentName:"p"},"items.done.concat(transferredItem)"),"), without worrying about the position in which it was dragged. To keep the code ",Object(a.b)("strong",{parentName:"p"},"cleaner")," we can create a function that works for each MuuriComponent and keep it in a different file."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"export function getOnSend(setItems) {\n  return function onSend({ key, fromId, toId }) {\n    // The id of the MuuriComponent that is sending the item.\n    fromId = fromId.toLowerCase();\n    // The id of the MuuriComponent that is receiving the item.\n    toId = toId.toLowerCase();\n\n    // Sync the state with the items.\n    setItems((items) => {\n      // New items object that we can modify.\n      const newItems = { ...items };\n      // The transferred item.\n      const transferredItem = newItems[fromId].find((item) => item.key === key);\n\n      // Updates the two categories in which the item has been traded.\n      newItems[fromId] = newItems[fromId].filter(\n        (item) => item !== transferredItem\n      );\n      newItems[toId] = newItems[toId].concat(transferredItem);\n\n      return newItems;\n    });\n  };\n}\n")),Object(a.b)("p",null,"We can now use the method for ",Object(a.b)("strong",{parentName:"p"},"each")," MuuriComponent."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),'import { getOnSend } from \'./utils\';\n\n// ...\n  <MuuriComponent\n    dragEnabled\n    id={"TODO"}\n    groupIds={["LIST"]}\n    dragSort={{ groupId: "LIST" }}\n    onSend={getOnSend(setItems)}\n  >\n')),Object(a.b)("h2",{id:"hook-usegrid-"},"Hook: useGrid \ud83d\udd0c"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"useGrid")," hook allow you to know which MuuriComponent the Item is on. See more ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"../hooks/useGrid"}),"here"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),'import { useGrid } from "muuri-react";\n\nconst Item = ({ text }) => {\n  const { id } = useGrid();\n  // Change the color based on the id.\n  const color = id === "TODO" ? "blue" : "green";\n\n  return (\n    <div className={`item color-${color}`}>\n      <div className="item-content">{text}</div>\n    </div>\n  );\n};\n')),Object(a.b)("h2",{id:"exclusive-drop-"},"Exclusive drop \ud83d\udeab"),Object(a.b)("p",null,"You can do some advanced stuff and control within which MuuriComponents a specific Item can be sorted and dragged into. To do that you can provide the groupId of these MuuriComponents in the ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"../api-reference/muuricomponent?id=dragSort"}),"dragSort")," prop."),Object(a.b)("p",null,"In the example below you can ",Object(a.b)("strong",{parentName:"p"},"send")," an Item from the first MuuriComponent to the second one, but not the opposite."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),"<MuuriComponent groupIds={[\"A\"]} dragSort={{ groupId: 'B' }} />\n<MuuriComponent groupIds={[\"B\"]} dragSort={{ groupId: 'B' }} />\n")),Object(a.b)("p",null,"If you want to implement a more complex logic, different for each Item, you can provide a ",Object(a.b)("inlineCode",{parentName:"p"},"function")," which receives the dragged Item as its first argument and should return an array of Muuri instances. You can easily access these instances by providing ids and groupIds to the ",Object(a.b)("inlineCode",{parentName:"p"},"muuriMap"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),'import { muuriMap } from "muuri-react";\n\n// Custom logic.\n<MuuriComponent\n  id={"id"}\n  groupIds={["groupId"]}\n  dragSort={(item) => {\n    // Dragged component.\n    const key = item.getKey();\n    const data = item.getData();\n    const props = item.getProps();\n\n    // Some Muuri instances.\n    const currentGrid = item.getGrid();\n    const gridsArray = muuriMap.getGroup("groupId");\n    const grid = muuriMap.get("id");\n\n    // Implement your logic...\n    // Return an array of Muuri instances into\n    // which the item can be dragged and sorted.\n    return anArrayOfGrids;\n  }}\n/>;\n')),Object(a.b)("h2",{id:"manual-reparenting-"},"Manual reparenting \ud83d\udc77"),Object(a.b)("p",null,"Reparenting is performed following a drag and drop. However, you can run it ",Object(a.b)("inlineCode",{parentName:"p"},"manually")," through the Muuri instance. This way group control is not enabled and you have to call onSend manually."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-jsx"}),"// ...\n// Grids.\nconst todoGrid = useRef();\nconst doneGrid = useRef();\n\n// Change the parent of the first 'todo' item.\nconst changeParent = () => {\n  // Move the first item of todoGrid as the last item of doneGrid.\n  todoGrid.current.send(0, doneGrid.current, -1);\n  // Sync the state.\n  onSend();\n};\n\nreturn (\n  <>\n    <button onClick={changeParent} />\n    {/* MuuriComponents */}\n    <MuuriComponent ref={todoGrid}>{children.todo}</MuuriComponent>\n    <MuuriComponent ref={doneGrid}>{children.done}</MuuriComponent>\n  </>\n);\n")),Object(a.b)("h2",{id:"how-is-that-possible-\ud83e\udd28"},"How is that possible? \ud83e\udd28"),Object(a.b)("p",null,"You may have wondered how it is possible that, during the reparenting, the ",Object(a.b)("inlineCode",{parentName:"p"},"Item")," can be inserted among the children of the new MuuriComponent in ",Object(a.b)("strong",{parentName:"p"},"any position")," (for example at the bottom), without worrying about the position in which it was dragged. This is because the order of the ",Object(a.b)("inlineCode",{parentName:"p"},"Item")," components is separated from the order of the elements in the DOM. This allows to have a very ",Object(a.b)("strong",{parentName:"p"},"simple implementation")," ",Object(a.b)("em",{parentName:"p"},"(In addition the Muuri-react diffing algorithm is optimized for insertions at the bottom)"),"."),Object(a.b)("img",{src:Object(i.a)("gifs/howisitpossible.gif")}))}d.isMDXComponent=!0},140:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return b}));var r=n(0),o=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=o.a.createContext({}),p=function(e){var t=o.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s({},t,{},e)),n},d=function(e){var t=p(e.components);return o.a.createElement(u.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},l=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=p(n),l=r,b=d["".concat(i,".").concat(l)]||d[l]||m[l]||a;return n?o.a.createElement(b,s({ref:t},u,{components:n})):o.a.createElement(b,s({ref:t},u))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=l;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<a;u++)i[u]=n[u];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}l.displayName="MDXCreateElement"},141:function(e,t,n){"use strict";var r=n(0),o=n(35);t.a=function(){return Object(r.useContext)(o.a)}},142:function(e,t,n){"use strict";n.d(t,"a",(function(){return o}));var r=n(141);function o(e){const{siteConfig:t}=Object(r.a)(),{baseUrl:n="/"}=t||{};if(!e)return e;return/^(https?:|\/\/)/.test(e)?e:e.startsWith("/")?n+e.slice(1):n+e}}}]);